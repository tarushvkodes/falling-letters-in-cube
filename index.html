<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Morphing Container with Falling Letters</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <!-- Matter.js physics engine -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      // Alias Matter.js modules.
      const Engine   = Matter.Engine,
            World    = Matter.World,
            Bodies   = Matter.Bodies,
            Body     = Matter.Body,
            Common   = Matter.Common;
      
      // Create physics engine and world.
      const engine = Engine.create();
      const world  = engine.world;
      world.gravity.y = 1; // moderate gravity

      // Get canvas and context.
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      
      // Resize canvas to full window.
      let containerCenter = { x: 0, y: 0 };
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        containerCenter = { x: canvas.width / 2, y: canvas.height / 2 };
      }
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();
      
      // --- Parameters ---
      const containerSize = 600;    // for our morphing container (used as a nominal side-length)
      const R = containerSize / 2;    // use R as the reference "radius" for all shapes
      const N = 50;                 // number of vertices for the polygon approximation
      
      // Container rotation (in radians)
      let containerAngle = 0;
      // Morph cycle period (in milliseconds)
      const morphPeriod = 15000;  // 15 seconds per full cycle
      
      // --- Helper functions to generate vertex sets in local coordinates (centered at 0,0) ---
      // Generate vertices for a square. We “simulate” a square by distributing N points along its perimeter.
      function generateSquareVertices(N, R) {
        // For a square that is inscribed in a circle of radius R,
        // the square's vertices (corners) are at (±R/√2, ±R/√2).
        // However, to get N points, we parametrize along the perimeter (perimeter length = 4L,
        // where L = side length = √2 * R).
        const L = Math.SQRT2 * R;
        const perim = 4 * L;
        let verts = [];
        for (let i = 0; i < N; i++) {
          const d = (i / N) * perim;
          let x, y;
          if (d < L) {
            // top edge: from left to right.
            x = -L/2 + (d);
            y = -L/2;
          } else if (d < 2 * L) {
            // right edge: from top to bottom.
            x = L/2;
            y = -L/2 + (d - L);
          } else if (d < 3 * L) {
            // bottom edge: from right to left.
            x = L/2 - (d - 2*L);
            y = L/2;
          } else {
            // left edge: from bottom to top.
            x = -L/2;
            y = L/2 - (d - 3*L);
          }
          verts.push({ x: x, y: y });
        }
        return verts;
      }
      
      // Generate vertices for a circle.
      function generateCircleVertices(N, R) {
        let verts = [];
        for (let i = 0; i < N; i++) {
          const angle = (i / N) * 2 * Math.PI;
          verts.push({ x: R * Math.cos(angle), y: R * Math.sin(angle) });
        }
        return verts;
      }
      
      // Generate vertices for an equilateral triangle.
      function generateTriangleVertices(N, R) {
        // Compute the 3 corner vertices of an equilateral triangle inscribed in a circle of radius R.
        let corners = [];
        for (let i = 0; i < 3; i++) {
          const angle = -Math.PI/2 + i * (2*Math.PI/3);
          corners.push({ x: R * Math.cos(angle), y: R * Math.sin(angle) });
        }
        // Now, distribute N points evenly along the triangle's perimeter.
        // The triangle's perimeter length:
        let sideLengths = [];
        let totalPerim = 0;
        for (let i = 0; i < 3; i++) {
          const p1 = corners[i];
          const p2 = corners[(i+1)%3];
          const d = Math.hypot(p2.x - p1.x, p2.y - p1.y);
          sideLengths.push(d);
          totalPerim += d;
        }
        let verts = [];
        for (let i = 0; i < N; i++) {
          const d = (i / N) * totalPerim;
          let acc = 0;
          for (let j = 0; j < 3; j++) {
            if (d >= acc && d < acc + sideLengths[j]) {
              const t = (d - acc) / sideLengths[j];
              const p1 = corners[j];
              const p2 = corners[(j+1)%3];
              const x = p1.x + t * (p2.x - p1.x);
              const y = p1.y + t * (p2.y - p1.y);
              verts.push({ x: x, y: y });
              break;
            }
            acc += sideLengths[j];
          }
        }
        return verts;
      }
      
      // Precompute vertex sets (all in local coordinates centered at (0,0)).
      const squareVerts = generateSquareVertices(N, R);
      const circleVerts = generateCircleVertices(N, R);
      const triangleVerts = generateTriangleVertices(N, R);
      
      // Interpolate linearly between two vertex sets (assumed to have the same length).
      function interpolateVerts(vertsA, vertsB, t) {
        let verts = [];
        for (let i = 0; i < vertsA.length; i++) {
          verts.push({
            x: vertsA[i].x * (1-t) + vertsB[i].x * t,
            y: vertsA[i].y * (1-t) + vertsB[i].y * t
          });
        }
        return verts;
      }
      
      // Given a phase (0 <= phase < 1), compute the current container shape (in local coordinates)
      // that cycles from square -> circle -> triangle -> square.
      function getContainerVertices(phase) {
        let verts;
        if (phase < 1/3) {
          // Morph from square to circle.
          let t = phase / (1/3);
          verts = interpolateVerts(squareVerts, circleVerts, t);
        } else if (phase < 2/3) {
          // Morph from circle to triangle.
          let t = (phase - 1/3) / (1/3);
          verts = interpolateVerts(circleVerts, triangleVerts, t);
        } else {
          // Morph from triangle to square.
          let t = (phase - 2/3) / (1/3);
          verts = interpolateVerts(triangleVerts, squareVerts, t);
        }
        return verts;
      }
      
      // Create the container body initially (static body).
      // We'll update its vertices each frame.
      let containerBody = Bodies.fromVertices(containerCenter.x, containerCenter.y, squareVerts, { isStatic: true, render: { fillStyle: "#fff" } }, true);
      World.add(world, containerBody);
      
      // --- Letter Spawning ---
      // Helpers for letters.
      function randomLetter() {
        return String.fromCharCode(65 + Math.floor(Math.random() * 26));
      }
      function randomColor() {
        const colors = ["#ff0000", "#00ff00", "#0000ff", "#ffff00", "#ff00ff", "#00ffff", "#ffffff"];
        return colors[Math.floor(Math.random() * colors.length)];
      }
      
      // Spawn a letter inside the container.
      // We choose a random point inside a circle of radius (R - margin) in container-local coordinates,
      // then transform it by rotating by containerAngle and translating by containerCenter.
      function spawnLetter() {
        const margin = 40;
        const effectiveR = R - margin;
        // Choose a random point (uniformly in polar coordinates).
        const angle = Math.random() * 2 * Math.PI;
        const radius = effectiveR * Math.sqrt(Math.random());
        const localX = radius * Math.cos(angle);
        const localY = radius * Math.sin(angle);
        // Transform to world coordinates.
        const cosA = Math.cos(containerAngle);
        const sinA = Math.sin(containerAngle);
        const worldX = containerCenter.x + localX * cosA - localY * sinA;
        const worldY = containerCenter.y + localX * sinA + localY * cosA;
        
        const letter = randomLetter();
        const size = Common.random(30, 80);
        const letterBody = Bodies.rectangle(worldX, worldY, size, size, {
          restitution: 0.3,
          friction: 0.1,
          density: 0.001
        });
        Body.setAngle(letterBody, Common.random(-0.3, 0.3));
        letterBody.customData = {
          letter: letter,
          size: size,
          color: randomColor()
        };
        World.add(world, letterBody);
      }
      setInterval(spawnLetter, 100);
      
      // --- Render Loop ---
      function render() {
        // Update physics.
        Engine.update(engine, 1000 / 60);
        
        // Update container morphing.
        const now = Date.now();
        const phase = ((now % morphPeriod) / morphPeriod); // cycles from 0 to 1 over morphPeriod
        const localVerts = getContainerVertices(phase);
        
        // Rotate the local vertices by containerAngle and then translate by containerCenter.
        let worldVerts = localVerts.map(v => {
          return {
            x: containerCenter.x + v.x * Math.cos(containerAngle) - v.y * Math.sin(containerAngle),
            y: containerCenter.y + v.x * Math.sin(containerAngle) + v.y * Math.cos(containerAngle)
          };
        });
        // Update containerBody vertices.
        Matter.Body.setVertices(containerBody, worldVerts);
        
        // Increment container rotation.
        containerAngle += 0.005; // adjust rotation speed as desired
        
        // Clear canvas.
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Render all bodies.
        world.bodies.forEach(body => {
          if (body.customData && body.customData.letter) {
            // Render letters.
            ctx.save();
            ctx.translate(body.position.x, body.position.y);
            ctx.rotate(body.angle);
            ctx.font = body.customData.size + "px sans-serif";
            ctx.fillStyle = body.customData.color;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(body.customData.letter, 0, 0);
            ctx.restore();
          } else if (body === containerBody) {
            // Render container body as a white filled shape.
            ctx.beginPath();
            ctx.moveTo(body.vertices[0].x, body.vertices[0].y);
            for (let i = 1; i < body.vertices.length; i++) {
              ctx.lineTo(body.vertices[i].x, body.vertices[i].y);
            }
            ctx.closePath();
            ctx.fillStyle = "#fff";
            ctx.fill();
          }
        });
        requestAnimationFrame(render);
      }
      render();
    });
  </script>
</body>
</html>