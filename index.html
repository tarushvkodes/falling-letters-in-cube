<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Morphing Container with Falling Letters (Spawn Inside)</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <!-- Matter.js physics engine -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      // Alias Matter.js modules.
      const Engine   = Matter.Engine,
            World    = Matter.World,
            Bodies   = Matter.Bodies,
            Body     = Matter.Body,
            Common   = Matter.Common;
      
      // Create physics engine and world.
      const engine = Engine.create();
      const world  = engine.world;
      world.gravity.y = 1; // moderate gravity

      // Get canvas and context.
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      
      // Resize canvas to full window.
      let containerCenter = { x: 0, y: 0 };
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        containerCenter = { x: canvas.width / 2, y: canvas.height / 2 };
      }
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();
      
      // --- Container Morphing Setup ---
      const containerSize = 600;    // nominal side length of container
      const R = containerSize / 2;    // reference "radius" for generating shapes
      const N = 50;                 // number of vertices for polygon approximation
      
      let containerAngle = 0;       // container rotation (radians)
      const morphPeriod = 15000;    // full morph cycle in ms
      
      // Global variable to store the current container shape in local coordinates.
      let currentLocalVerts = null;
      
      // Generate vertex sets (in local coordinates, centered at (0,0)).
      function generateSquareVertices(N, R) {
        const L = Math.SQRT2 * R;  // side length of inscribed square
        const perim = 4 * L;
        let verts = [];
        for (let i = 0; i < N; i++) {
          const d = (i / N) * perim;
          let x, y;
          if (d < L) {
            x = -L/2 + d;
            y = -L/2;
          } else if (d < 2 * L) {
            x = L/2;
            y = -L/2 + (d - L);
          } else if (d < 3 * L) {
            x = L/2 - (d - 2*L);
            y = L/2;
          } else {
            x = -L/2;
            y = L/2 - (d - 3*L);
          }
          verts.push({ x: x, y: y });
        }
        return verts;
      }
      
      function generateCircleVertices(N, R) {
        let verts = [];
        for (let i = 0; i < N; i++) {
          const angle = (i / N) * 2 * Math.PI;
          verts.push({ x: R * Math.cos(angle), y: R * Math.sin(angle) });
        }
        return verts;
      }
      
      function generateTriangleVertices(N, R) {
        let corners = [];
        for (let i = 0; i < 3; i++) {
          const angle = -Math.PI/2 + i * (2*Math.PI/3);
          corners.push({ x: R * Math.cos(angle), y: R * Math.sin(angle) });
        }
        let sideLengths = [];
        let totalPerim = 0;
        for (let i = 0; i < 3; i++) {
          const p1 = corners[i];
          const p2 = corners[(i+1)%3];
          const d = Math.hypot(p2.x - p1.x, p2.y - p1.y);
          sideLengths.push(d);
          totalPerim += d;
        }
        let verts = [];
        for (let i = 0; i < N; i++) {
          const d = (i / N) * totalPerim;
          let acc = 0;
          for (let j = 0; j < 3; j++) {
            if (d >= acc && d < acc + sideLengths[j]) {
              const t = (d - acc) / sideLengths[j];
              const p1 = corners[j];
              const p2 = corners[(j+1)%3];
              const x = p1.x + t * (p2.x - p1.x);
              const y = p1.y + t * (p2.y - p1.y);
              verts.push({ x: x, y: y });
              break;
            }
            acc += sideLengths[j];
          }
        }
        return verts;
      }
      
      const squareVerts = generateSquareVertices(N, R);
      const circleVerts = generateCircleVertices(N, R);
      const triangleVerts = generateTriangleVertices(N, R);
      
      // Interpolate between two vertex sets.
      function interpolateVerts(vertsA, vertsB, t) {
        let verts = [];
        for (let i = 0; i < vertsA.length; i++) {
          verts.push({
            x: vertsA[i].x * (1-t) + vertsB[i].x * t,
            y: vertsA[i].y * (1-t) + vertsB[i].y * t
          });
        }
        return verts;
      }
      
      // Compute current container vertices (local coordinates) by morphing between shapes.
      function getContainerVertices(phase) {
        let verts;
        if (phase < 1/3) {
          let t = phase / (1/3);
          verts = interpolateVerts(squareVerts, circleVerts, t);
        } else if (phase < 2/3) {
          let t = (phase - 1/3) / (1/3);
          verts = interpolateVerts(circleVerts, triangleVerts, t);
        } else {
          let t = (phase - 2/3) / (1/3);
          verts = interpolateVerts(triangleVerts, squareVerts, t);
        }
        return verts;
      }
      
      // Create the container body (static). We'll update its vertices every frame.
      let containerBody = Bodies.fromVertices(containerCenter.x, containerCenter.y, squareVerts, { isStatic: true, render: { fillStyle: "#fff" } }, true);
      World.add(world, containerBody);
      
      // --- Point-in-Polygon and Sampling ---
      function pointInPolygon(point, polygon) {
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
          const xi = polygon[i].x, yi = polygon[i].y;
          const xj = polygon[j].x, yj = polygon[j].y;
          const intersect = ((yi > point.y) !== (yj > point.y)) &&
                            (point.x < (xj - xi) * (point.y - yi) / (yj - yi + 0.0000001) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }
      
      function samplePointInPolygon(polygon) {
        // Compute bounding box.
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        polygon.forEach(p => {
          if (p.x < minX) minX = p.x;
          if (p.x > maxX) maxX = p.x;
          if (p.y < minY) minY = p.y;
          if (p.y > maxY) maxY = p.y;
        });
        // Rejection sampling.
        let pt;
        for (let i = 0; i < 100; i++) {
          pt = {
            x: minX + Math.random() * (maxX - minX),
            y: minY + Math.random() * (maxY - minY)
          };
          if (pointInPolygon(pt, polygon)) {
            return pt;
          }
        }
        // Fallback: return center.
        return { x: 0, y: 0 };
      }
      
      // --- Letter Spawning ---
      // Helpers for letters.
      function randomLetter() {
        return String.fromCharCode(65 + Math.floor(Math.random() * 26));
      }
      function randomColor() {
        const colors = ["#ff0000", "#00ff00", "#0000ff", "#ffff00", "#ff00ff", "#00ffff", "#ffffff"];
        return colors[Math.floor(Math.random() * colors.length)];
      }
      
      // Spawn a letter inside the container.
      function spawnLetter() {
        if (!currentLocalVerts) return;  // wait until container shape is computed
        // Sample a random point inside the container (in local coordinates).
        const localPt = samplePointInPolygon(currentLocalVerts);
        // Transform the local point to world coordinates using containerAngle and containerCenter.
        const cosA = Math.cos(containerAngle);
        const sinA = Math.sin(containerAngle);
        const worldX = containerCenter.x + localPt.x * cosA - localPt.y * sinA;
        const worldY = containerCenter.y + localPt.x * sinA + localPt.y * cosA;
        
        const letter = randomLetter();
        const size = Common.random(30, 80);
        const letterBody = Bodies.rectangle(worldX, worldY, size, size, {
          restitution: 0.3,
          friction: 0.1,
          density: 0.001
        });
        Body.setAngle(letterBody, Common.random(-0.3, 0.3));
        letterBody.customData = {
          letter: letter,
          size: size,
          color: randomColor()
        };
        World.add(world, letterBody);
      }
      setInterval(spawnLetter, 100);
      
      // --- Render Loop ---
      function render() {
        Engine.update(engine, 1000 / 60);
        
        // Compute morph phase and update container shape.
        const now = Date.now();
        const phase = (now % morphPeriod) / morphPeriod;
        currentLocalVerts = getContainerVertices(phase);
        
        // Transform local container vertices to world coordinates.
        let worldVerts = currentLocalVerts.map(v => {
          return {
            x: containerCenter.x + v.x * Math.cos(containerAngle) - v.y * Math.sin(containerAngle),
            y: containerCenter.y + v.x * Math.sin(containerAngle) + v.y * Math.cos(containerAngle)
          };
        });
        Matter.Body.setVertices(containerBody, worldVerts);
        
        // Increment container rotation.
        containerAngle += 0.005;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Render all bodies.
        world.bodies.forEach(body => {
          if (body.customData && body.customData.letter) {
            ctx.save();
            ctx.translate(body.position.x, body.position.y);
            ctx.rotate(body.angle);
            ctx.font = body.customData.size + "px sans-serif";
            ctx.fillStyle = body.customData.color;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(body.customData.letter, 0, 0);
            ctx.restore();
          } else if (body === containerBody) {
            // Render container as a white filled shape.
            ctx.beginPath();
            ctx.moveTo(body.vertices[0].x, body.vertices[0].y);
            for (let i = 1; i < body.vertices.length; i++) {
              ctx.lineTo(body.vertices[i].x, body.vertices[i].y);
            }
            ctx.closePath();
            ctx.fillStyle = "#fff";
            ctx.fill();
          }
        });
        requestAnimationFrame(render);
      }
      render();
    });
  </script>
</body>
</html>